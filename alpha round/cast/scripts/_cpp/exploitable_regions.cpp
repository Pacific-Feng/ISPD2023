#include "exploitable_regions.h"

// This code is to be used along with check.tcl
//
// Simply compile the code via ./compile.sh from within this folder
//
// The main code, that is for determination of exploitable regions based on non-occupied sites, was provided as
// courtesy by team CUEDA (The Chinese University of Hong Kong; Fangzhou Wang, Qijing Wang, Bangqi Fu, Shui Jiang,
// Xiaopeng Zhang, Tsung-Yi Ho, Evangeline F.Y. Young) during ISPD'22 contest. Many thanks to them!
//
// Further edits by Johann Knechtel, NYUAD
//
int main(int argc, char** argv) {
    
    std::cout.imbue(std::locale(std::cout.getloc(), new digit_sep));

    std::cout << "----------------------------" << std::endl;
    std::cout << "Evaluate exploitable regions" << std::endl;
    std::cout << "----------------------------" << std::endl;

    if (argc < 3) {
	std::cerr << " Missing 2 call parameters: place_file_name, exploitable_region_size_threshold; exiting" << std::endl;
        exit(1);
    }
    else {
	std::cout << " Parameters provided: place_file_name = \"" << argv[1] << "\", exploitable_region_size_threshold = \"" << argv[2] << "\"" << std::endl;
    }

    Handler handler(std::string(argv[1]), std::atoi(argv[2]));

    handler.readPlacement();
    handler.markInstOccupancy();
    handler.findIslands();
    handler.buildIslandConnectivity();

    // calculate metrics over exploitable regions
    //
    int all_sites_sum = 0;    
    int all_sites_max = 0;
    vector<int> region_sites_sum = vector<int>(handler.exploitable_regions.size(), 0);

    for (int r = 0; r < handler.exploitable_regions.size(); r++) {

        for (int island_idx : handler.exploitable_regions[r]) {
	    region_sites_sum[r] += handler.islands[island_idx].size;
        }
	
	all_sites_sum += region_sites_sum[r];

	if (region_sites_sum[r] > all_sites_max) {
		all_sites_max = region_sites_sum[r];
	}
    }

//    for (int r = 0; r < region_sites_sum.size(); r++) {
//	    std::cout << " Region " << r << ": " << region_sites_sum[r] << std::endl;
//    }

    std::cout << std::endl;
    std::cout << " Final report:" << std::endl;
    std::cout << "  Num of exploitable regions: " << handler.exploitable_regions.size() << std::endl;
    std::cout << "  Sum of sites across all regions: " << all_sites_sum << std::endl;
    std::cout << "  Max of sites across all regions: " << all_sites_max << std::endl;
    std::cout << "  Avg of sites across all regions: " << static_cast<double>(all_sites_sum) / handler.exploitable_regions.size() << std::endl;
    std::sort(region_sites_sum.begin(), region_sites_sum.end());
    std::cout << "  Median of sites across all regions: " << region_sites_sum[region_sites_sum.size()/2] << std::endl;
}

void Handler::readPlacement() {

    string dummy;
    double core_lx, core_ly, core_hx, core_hy;
    string line, name;
    int inst_id, row_id, start_site, width_in_site, total_sites_occ;

    std::cout << " Parsing placement info file: " << place_file_name << std::endl;

    std::ifstream place_file(place_file_name);

    if (!place_file.is_open()) {
	std::cerr << " Failed to open file; exiting!" << std::endl;  
        exit(1);
    }

    place_file >> dummy >> core_lx >> core_ly >> core_hx >> core_hy;
    place_file >> dummy >> num_rows;
    place_file >> dummy >> num_sites_per_row;
    place_file >> dummy >> site_width;
    place_file >> dummy >> site_height;

    inst_id = 0;
    insts.clear();
    total_sites_occ = 0;

    while (std::getline(place_file, line)) {

        if (line.find("inst") == string::npos) continue;

        std::stringstream ss(line);
        ss >> name >> start_site >> row_id >> width_in_site;

	total_sites_occ += width_in_site;

        insts.emplace_back(name, inst_id, row_id, start_site, width_in_site);
        inst_id += 1;
    }

    std::cout << " Finish parsing." << std::endl;
    std::cout << "  Num of rows: " << num_rows << std::endl;
    std::cout << "  Num of sites per row: " << num_sites_per_row << std::endl;
    std::cout << "  Num of sites in total: " << num_rows * num_sites_per_row << std::endl;
    std::cout << "  Num of std cells reported in file: " << insts.size() << std::endl;
    std::cout << "  Num of sites occupied by those std cells: " << total_sites_occ << std::endl;
    std::cout << "  Utilization imposed by those std cells: " << static_cast<double>(total_sites_occ) / (num_rows * num_sites_per_row) << std::endl;
}

void Handler::markInstOccupancy() {
	
    std::cout << " Marking sites occupied by standard cells." << std::endl;

    occupancy_graph.clear();
    occupancy_graph.resize(num_rows, vector<int>(num_sites_per_row, -1));

    for(auto& inst: insts) {

        int r = inst.row_id;

        for (int c = inst.start_site; c < inst.start_site + inst.width_in_site; c++) {

            if (occupancy_graph[r][c] != -1) {
		    std::cerr << "  Instance overlap detected at row: " << r << ", site: " << c << std::endl;
            }

            occupancy_graph[r][c] = inst.idx;
        }
    }

    std::cout << " Finish marking occupancy." << std::endl;
}

void Handler::findIslands() {

    std::cout << " Searching for islands" << std::endl;

    islands.clear();
    assigned_island.clear();
    assigned_island.resize(num_rows, vector<int>(num_sites_per_row, -1));

    // Note: currently we dont have a hard-coded search range (e.g., 50, 100)
    int num_islands = 0;

    for (int r = 0; r < num_rows; r++) {
        for (int c = 0; c < num_sites_per_row - 1; c++) {

            if (occupancy_graph[r][c] == -1 && occupancy_graph[r][c+1] == -1) {

                // start from here
                int start_c = c;
                int end_c = c + 1;
                while (end_c < num_sites_per_row) {
                    if (occupancy_graph[r][end_c] != -1) {
                        break;
                    }
                    end_c += 1;
                }

                islands.emplace_back(num_islands, r, start_c, end_c - 1);
                num_islands += 1;

                // mark islands
                for(int k = start_c; k <= end_c - 1; k++) {
                    assigned_island[r][k] = islands.back().idx;
                }
            
                if(end_c == num_sites_per_row) {
                    break;
                }

                c = end_c;
            }
        }
    }

    std::cout << " Finish search." << std::endl;
    std::cout << "  Found " << islands.size() << " islands " << std::endl;
}

void Handler::buildIslandConnectivity() {    

	std::cout << " Determining exploitable regions." << std::endl;

	exploitable_regions.clear();
	island_adj_list.clear();
	island_adj_list.resize(islands.size());

	std::cout << "  Computing islands' adjacency lists." << std::endl;

	for (int i = 0;i < islands.size(); i++) {

	    auto& island_i = islands[i];

	    for (int j = i+1; j < islands.size();j++) {

		auto& island_j = islands[j];

		if (abs(island_i.row_id - island_j.row_id) == 1) {
		    if (! (island_i.start_site > island_j.end_site || island_j.start_site > island_i.end_site) ) {
			island_adj_list[i].push_back(j);
			island_adj_list[j].push_back(i);
		    }
		}
	    }
	}

	std::cout << "  Finish computing islands' adjacency lists." << std::endl;

	// search for exploitable regions, i.e., consecutive islands w/ some sites abutting
	vector<bool> visited(islands.size(), false);

	auto bfs = [&](int start) {

	    vector<int> connected_component;
	    int connected_component_num_sites = 0;
	    int u;
	    queue<int> q;

	    visited[start] = true;
	    q.push(start);

	    connected_component.push_back(start);
	    connected_component_num_sites += islands[start].size;

	    while (q.empty() == false) {
		u = q.front();
		q.pop();
		for (int v: island_adj_list[u]) {
		    if (visited[v] == false) {
			visited[v] = true;
			q.push(v);
			connected_component.push_back(v);
			connected_component_num_sites += islands[v].size;
		    }
		}
	    }

	    if (connected_component_num_sites >= exploitable_region_size_threshold) {
		exploitable_regions.emplace_back(std::move(connected_component));
	    }
	};

	std::cout << "  Building up island connectivity." << std::endl;

	for (int i = 0; i < islands.size(); i++) {
	    if (visited[i] == false) {
		bfs(i);
	    }
	}

	std::cout << "  Finish building up island connectivity." << std::endl;

	std::cout << " Finish determining exploitable regions." << std::endl;
}
