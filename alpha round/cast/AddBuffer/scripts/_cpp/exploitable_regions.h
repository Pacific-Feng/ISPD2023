#pragma once

// std library
#include <fstream>
#include <iostream>
#include <locale>
#include <vector>
#include <algorithm>
#include <string>
#include <sstream>
#include <queue>

using std::vector;
using std::string;
using std::queue;

class Island {
    public:
        int idx;
        int row_id;
        int start_site;
        int end_site;
        int size = 0;

        Island() {}
        Island(int idx_, int row_id_, int start_site_, int end_site_)
            : idx(idx_), row_id(row_id_), start_site(start_site_), end_site(end_site_) {size = end_site - start_site + 1;}
};

class Inst {
    public:
        string obj_str;
        int idx;
        int row_id;
        int start_site;
        int width_in_site;

        Inst(string& obj_str_, int idx_, int row_id_, int start_site_, int width_in_site_)
            : obj_str(obj_str_), idx(idx_), row_id(row_id_), start_site(start_site_), width_in_site(width_in_site_) {}
};


class Handler {
    public:
        int exploitable_region_size_threshold; 
        string place_file_name;

        double site_height = 0;
        double site_width = 0;
        int num_rows = 0;
        int num_sites_per_row = 0;

        vector<Inst> insts;

        vector<vector<int>> occupancy_graph;

        vector<Island> islands;
        vector<vector<int>> assigned_island;

        vector<vector<int>> island_adj_list;
        vector<vector<int>> exploitable_regions;

        Handler(string place_file_name_, int exploitable_region_size_threshold_)
		: place_file_name(place_file_name_), exploitable_region_size_threshold(exploitable_region_size_threshold_) {}

        void readPlacement();
        void markInstOccupancy();
        void findIslands();
        void buildIslandConnectivity();
};
 
struct digit_sep : std::numpunct<char>
{
	char do_thousands_sep() const { return ','; }  // separate groups of digits with ','
	std::string do_grouping() const { return "\3"; } // groups of 3 digit
};
